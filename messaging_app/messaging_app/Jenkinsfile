pipeline {
    agent any
    
    parameters {
        booleanParam(
            name: 'FORCE_DOCKER_BUILD',
            defaultValue: false,
            description: 'Force Docker image build regardless of branch'
        )
        booleanParam(
            name: 'FORCE_DOCKER_PUSH',
            defaultValue: false,
            description: 'Force Docker image push regardless of branch'
        )
        choice(
            name: 'DOCKER_TAG_STRATEGY',
            choices: ['build-number', 'git-commit', 'timestamp'],
            description: 'Strategy for Docker image tagging'
        )
    }
    
    environment {
        // Define environment variables
        PYTHON_VERSION = '3.9'
        VIRTUAL_ENV = 'venv'
        GITHUB_CREDENTIALS_ID = 'github-credentials' // Update this to match your Jenkins credentials ID
        
        // Docker configuration
        DOCKER_REGISTRY = 'docker.io' 
        DOCKER_REPOSITORY = 'AJIyanu/alx-backend-python' 
        DOCKER_CREDENTIALS_ID = 'docker-hub-credentials' 
        
        // Image versioning
        IMAGE_TAG = "${BUILD_NUMBER}"
        LATEST_TAG = 'latest'
    }
    
    options {
        // Keep builds for 10 days or last 10 builds
        buildDiscarder(logRotator(daysToKeepStr: '10', numToKeepStr: '10'))
        
        // Timeout the build after 30 minutes
        timeout(time: 30, unit: 'MINUTES')
        
        // Skip default checkout
        skipDefaultCheckout(true)
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "ðŸ”„ Checking out code from GitHub..."
                    
                    // Checkout code using GitHub credentials
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/main']], // Change to your default branch if different
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                            [$class: 'CloneOption', depth: 1, noTags: false, reference: '', shallow: true],
                            [$class: 'CheckoutOption', timeout: 20]
                        ],
                        submoduleCfg: [],
                        userRemoteConfigs: [[
                            credentialsId: "${GITHUB_CREDENTIALS_ID}",
                            url: 'https://github.com/AJIyanu/alx-backend-python' // Update with your repo URL
                        ]]
                    ])
                    
                    // Display current commit info
                    sh '''
                        echo "ðŸ“‹ Current commit information:"
                        git log -1 --oneline
                        git branch -a
                    '''
                }
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    echo "ðŸ”§ Setting up Python environment..."
                    
                    // Create virtual environment and install dependencies
                    sh '''
                        # Remove existing virtual environment if it exists
                        if [ -d "${VIRTUAL_ENV}" ]; then
                            rm -rf ${VIRTUAL_ENV}
                        fi
                        
                        # Create new virtual environment
                        python${PYTHON_VERSION} -m venv ${VIRTUAL_ENV}
                        
                        # Activate virtual environment and upgrade pip
                        . ${VIRTUAL_ENV}/bin/activate
                        pip3 install --upgrade pip setuptools wheel
                        
                        # Install dependencies
                        if [ -f "requirements.txt" ]; then
                            echo "ðŸ“¦ Installing dependencies from requirements.txt..."
                            pip3 install -r messaging_app/requirements.txt
                        else
                            echo "âš ï¸  No requirements.txt found, installing basic testing dependencies..."
                            pip install pytest pytest-html pytest-cov pytest-xdist
                        fi
                        
                        # Install development dependencies if they exist
                        if [ -f "requirements-dev.txt" ]; then
                            echo "ðŸ“¦ Installing development dependencies..."
                            pip3 install -r messaging_app/requirements.txt
                        fi
                        
                        # Display installed packages
                        echo "ðŸ“‹ Installed packages:"
                        pip list
                    '''
                }
            }
        }
        
        stage('Code Quality Checks') {
            parallel {
                stage('Linting') {
                    steps {
                        script {
                            echo "ðŸ” Running code quality checks..."
                            
                            sh '''
                                . ${VIRTUAL_ENV}/bin/activate
                                
                                # Install linting tools if not already installed
                                pip install flake8 pylint black isort || true
                                
                                # Create reports directory
                                mkdir -p reports
                                
                                # Run flake8 (style guide enforcement)
                                echo "Running flake8..."
                                flake8 . --max-line-length=88 --extend-ignore=E203,W503 --format=html --htmldir=reports/flake8 || true
                                flake8 . --max-line-length=88 --extend-ignore=E203,W503 --tee --output-file=reports/flake8.txt || true
                                
                                # Run pylint (code analysis)
                                echo "Running pylint..."
                                find . -name "*.py" -not -path "./venv/*" -not -path "./${VIRTUAL_ENV}/*" | xargs pylint --output-format=json > reports/pylint.json || true
                                
                                # Check code formatting with black
                                echo "Checking code formatting with black..."
                                black --check --diff . > reports/black-check.txt || true
                                
                                # Check import sorting with isort
                                echo "Checking import sorting with isort..."
                                isort --check-only --diff . > reports/isort-check.txt || true
                            '''
                        }
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        script {
                            echo "ðŸ”’ Running security checks..."
                            
                            sh '''
                                . ${VIRTUAL_ENV}/bin/activate
                                
                                # Install security scanning tools
                                pip install bandit safety || true
                                
                                # Run bandit security linter
                                echo "Running bandit security scan..."
                                bandit -r . -f json -o reports/bandit.json || true
                                bandit -r . -f txt -o reports/bandit.txt || true
                                
                                # Run safety check for known security vulnerabilities
                                echo "Running safety check..."
                                safety check --json --output reports/safety.json || true
                                safety check --output reports/safety.txt || true
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Run Tests') {
            steps {
                script {
                    echo "ðŸ§ª Running tests with pytest..."
                    
                    sh '''
                        . ${VIRTUAL_ENV}/bin/activate
                        
                        # Create test reports directory
                        mkdir -p reports/tests
                        
                        # Run pytest with coverage and multiple output formats
                        pytest \
                            --verbose \
                            --tb=short \
                            --cov=. \
                            --cov-report=html:reports/coverage \
                            --cov-report=xml:reports/coverage.xml \
                            --cov-report=term-missing \
                            --junit-xml=reports/tests/junit.xml \
                            --html=reports/tests/report.html \
                            --self-contained-html \
                            -n auto \
                            tests/ || TEST_RESULT=$?
                        
                        # Display test summary
                        echo "ðŸ“Š Test execution completed"
                        
                        # Exit with test result code
                        exit ${TEST_RESULT:-0}
                    '''
                }
            }
            post {
                always {
                    // Archive test results
                    junit 'reports/tests/junit.xml'
                    
                    // Publish HTML test report
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'reports/tests',
                        reportFiles: 'report.html',
                        reportName: 'Test Report'
                    ])
                    
                    // Publish coverage report
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'reports/coverage',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report'
                    ])
                }
            }
        }
        
        stage('Generate Reports') {
            steps {
                script {
                    echo "ðŸ“ˆ Generating additional reports..."
                    
                    sh '''
                        . ${VIRTUAL_ENV}/bin/activate
                        
                        # Create a comprehensive build summary
                        cat > reports/build-summary.txt << EOF
MESSAGING APP BUILD SUMMARY
============================
Build Number: ${BUILD_NUMBER}
Build URL: ${BUILD_URL}
Git Commit: $(git rev-parse HEAD)
Git Branch: $(git rev-parse --abbrev-ref HEAD)
Build Date: $(date)
Build Duration: ${BUILD_DURATION:-"N/A"}

ENVIRONMENT INFO:
- Python Version: $(python --version)
- Jenkins Node: ${NODE_NAME}
- Workspace: ${WORKSPACE}

FILES PROCESSED:
$(find . -name "*.py" -not -path "./venv/*" -not -path "./${VIRTUAL_ENV}/*" | wc -l) Python files found

REPORTS GENERATED:
- Test Report: reports/tests/report.html
- Coverage Report: reports/coverage/index.html
- JUnit XML: reports/tests/junit.xml
- Coverage XML: reports/coverage.xml

EOF
                        
                        echo "ðŸ“‹ Build summary generated"
                        cat reports/build-summary.txt
                    '''
                }
            }
        }
        
        stage('Build Docker Image') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                    branch 'develop'
                    expression { return params.FORCE_DOCKER_BUILD == true }
                }
            }
            steps {
                script {
                    echo "ðŸ³ Building Docker image..."
                    
                    // Create Dockerfile if it doesn't exist
                    sh '''
                        if [ ! -f "Dockerfile" ]; then
                            echo "âš ï¸  No Dockerfile found. Creating a default Dockerfile..."
                            cat > Dockerfile << 'DOCKERFILE_EOF'
# Use Python slim image
FROM python:3.9-slim

# Set working directory
WORKDIR /app

# Set environment variables
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1

# Install system dependencies
RUN apt-get update \\
    && apt-get install -y --no-install-recommends \\
        gcc \\
        libc6-dev \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements*.txt ./

# Install Python dependencies
RUN pip install --no-cache-dir --upgrade pip setuptools wheel \\
    && pip install --no-cache-dir -r requirements.txt \\
    && if [ -f "requirements-prod.txt" ]; then pip install --no-cache-dir -r requirements-prod.txt; fi

# Copy application code
COPY . .

# Create non-root user for security
RUN groupadd -r appuser && useradd -r -g appuser appuser \\
    && chown -R appuser:appuser /app
USER appuser

# Expose port (update based on your app)
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\
    CMD python -c "import requests; requests.get('http://localhost:8000/health')" || exit 1

# Default command (update based on your app's entry point)
CMD ["python", "-m", "gunicorn", "--bind", "0.0.0.0:8000", "--workers", "4", "app:app"]
DOCKERFILE_EOF
                        else
                            echo "âœ… Dockerfile found"
                        fi
                    '''
                    
                    // Build the Docker image
                    def dockerImage = docker.build(
                        "${DOCKER_REPOSITORY}:${IMAGE_TAG}",
                        "--no-cache --pull --label 'build.number=${BUILD_NUMBER}' --label 'build.url=${BUILD_URL}' --label 'git.commit=${GIT_COMMIT}' --label 'git.branch=${GIT_BRANCH}' ."
                    )
                    
                    // Tag the image with latest
                    dockerImage.tag("${LATEST_TAG}")
                    
                    // Store image for later use
                    env.DOCKER_IMAGE_ID = dockerImage.id
                    
                    echo "âœ… Docker image built successfully: ${DOCKER_REPOSITORY}:${IMAGE_TAG}"
                }
            }
            post {
                always {
                    // Clean up dangling images to save space
                    sh 'docker image prune -f || true'
                }
            }
        }
        
        stage('Test Docker Image') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                    branch 'develop'
                    expression { return params.FORCE_DOCKER_BUILD == true }
                }
            }
            steps {
                script {
                    echo "ðŸ§ª Testing Docker image..."
                    
                    try {
                        // Run basic tests on the Docker image
                        sh '''
                            echo "Testing Docker image basic functionality..."
                            
                            # Test image can be instantiated
                            CONTAINER_ID=$(docker run -d --name test-container-${BUILD_NUMBER} ${DOCKER_REPOSITORY}:${IMAGE_TAG})
                            echo "Container started: $CONTAINER_ID"
                            
                            # Wait for container to be ready
                            sleep 10
                            
                            # Check if container is running
                            if docker ps | grep -q test-container-${BUILD_NUMBER}; then
                                echo "âœ… Container is running successfully"
                                
                                # Run basic health checks
                                docker exec test-container-${BUILD_NUMBER} python --version
                                docker exec test-container-${BUILD_NUMBER} pip list
                                
                                # Check if app dependencies are installed (customize based on your app)
                                docker exec test-container-${BUILD_NUMBER} python -c "import flask" || echo "âš ï¸  Flask not found"
                                docker exec test-container-${BUILD_NUMBER} python -c "import requests" || echo "âš ï¸  Requests not found"
                            else
                                echo "âŒ Container failed to start"
                                docker logs test-container-${BUILD_NUMBER}
                                exit 1
                            fi
                        '''
                        
                        // Test image security
                        sh '''
                            echo "Running security scan on Docker image..."
                            
                            # Install and run Trivy if available (optional)
                            if command -v trivy &> /dev/null; then
                                echo "Running Trivy security scan..."
                                trivy image --format json --output reports/docker-security.json ${DOCKER_REPOSITORY}:${IMAGE_TAG} || true
                                trivy image --severity HIGH,CRITICAL ${DOCKER_REPOSITORY}:${IMAGE_TAG} || true
                            else
                                echo "âš ï¸  Trivy not available, skipping security scan"
                            fi
                        '''
                        
                    } finally {
                        // Always clean up test containers
                        sh '''
                            echo "Cleaning up test containers..."
                            docker stop test-container-${BUILD_NUMBER} || true
                            docker rm test-container-${BUILD_NUMBER} || true
                        '''
                    }
                }
            }
        }
        
        stage('Push Docker Image') {
            when {
                allOf {
                    anyOf {
                        branch 'main'
                        branch 'master'
                        expression { return params.FORCE_DOCKER_PUSH == true }
                    }
                    expression { return currentBuild.result != 'FAILURE' }
                }
            }
            steps {
                script {
                    echo "ðŸš€ Pushing Docker image to registry..."
                    
                    // Login to Docker registry and push
                    docker.withRegistry("https://${DOCKER_REGISTRY}", "${DOCKER_CREDENTIALS_ID}") {
                        
                        // Push versioned image
                        def dockerImage = docker.image("${DOCKER_REPOSITORY}:${IMAGE_TAG}")
                        dockerImage.push("${IMAGE_TAG}")
                        dockerImage.push("${LATEST_TAG}")
                        
                        // Add additional tags if needed
                        if (env.GIT_BRANCH == 'main' || env.GIT_BRANCH == 'master') {
                            dockerImage.push("stable")
                        }
                        
                        // Create manifest for multi-arch if needed (uncomment if required)
                        // sh """
                        //     docker manifest create ${DOCKER_REPOSITORY}:${IMAGE_TAG} \\
                        //         ${DOCKER_REPOSITORY}:${IMAGE_TAG}-amd64 \\
                        //         ${DOCKER_REPOSITORY}:${IMAGE_TAG}-arm64
                        //     docker manifest push ${DOCKER_REPOSITORY}:${IMAGE_TAG}
                        // """
                        
                        echo "âœ… Docker image pushed successfully!"
                        echo "ðŸ“¦ Image: ${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:${IMAGE_TAG}"
                        echo "ðŸ“¦ Image: ${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:${LATEST_TAG}"
                    }
                    
                    // Update build summary with Docker info
                    sh '''
                        cat >> reports/build-summary.txt << EOF

DOCKER IMAGE INFO:
- Registry: ${DOCKER_REGISTRY}
- Repository: ${DOCKER_REPOSITORY}
- Tags: ${IMAGE_TAG}, ${LATEST_TAG}
- Image ID: ${DOCKER_IMAGE_ID}
- Push Status: SUCCESS

DOCKER COMMANDS TO USE IMAGE:
docker pull ${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:${IMAGE_TAG}
docker run -d -p 8000:8000 --name messaging-app ${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:${IMAGE_TAG}

EOF
                    '''
                }
            }
            post {
                always {
                    // Clean up local images after push to save space
                    sh '''
                        echo "Cleaning up local Docker images..."
                        docker rmi ${DOCKER_REPOSITORY}:${IMAGE_TAG} || true
                        docker rmi ${DOCKER_REPOSITORY}:${LATEST_TAG} || true
                        docker image prune -f || true
                    '''
                }
            }
        }
    }
    
    post {
        always {
            echo "ðŸ§¹ Cleaning up workspace..."
            
            // Archive all reports
            archiveArtifacts artifacts: 'reports/**/*', fingerprint: true, allowEmptyArchive: true
            
            // Clean up virtual environment but keep reports
            sh '''
                if [ -d "${VIRTUAL_ENV}" ]; then
                    rm -rf ${VIRTUAL_ENV}
                fi
            '''
        }
        
        success {
            echo "âœ… Pipeline completed successfully!"
            
            // Send success notification (uncomment and configure as needed)
            // emailext (
            //     subject: "âœ… Build Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
            //     body: "The build was successful. View details at: ${env.BUILD_URL}",
            //     to: "developer@yourcompany.com"
            // )
        }
        
        failure {
            echo "âŒ Pipeline failed!"
            
            // Send failure notification (uncomment and configure as needed)
            // emailext (
            //     subject: "âŒ Build Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
            //     body: "The build failed. View details at: ${env.BUILD_URL}",
            //     to: "developer@yourcompany.com"
            // )
        }
        
        unstable {
            echo "âš ï¸ Pipeline completed with warnings!"
        }
    }
}